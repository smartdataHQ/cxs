#!/usr/bin/env bash
set -euo pipefail

GITHUB_OWNER="${GITHUB_OWNER:-smartdataHQ}"
GITHUB_REPO="${GITHUB_REPO:-cxs}"
GITHUB_PATH=".local"
DEFAULT_GITHUB_REF="${DEFAULT_GITHUB_REF:-main}"
DEFAULT_TARGET_DIR="mimir-onprem"

usage() {
  cat <<'USAGE'
Usage: install.sh [options]

Fetch the .local stack from GitHub and run docker compose.

Options:
  -t, --target <dir>     Target directory for the stack (default: mimir-onprem)
  -e, --env-file <file1,file2,...>  Comma-separated paths to environment files (non-sensitive first, sensitive last; overrides apply in order)
      --no-up            Download only; do not run docker compose up
      --no-interactive   Skip interactive secret prompts (use existing files)
      --ref <git-ref>    Git ref (branch/tag/SHA) to fetch (defaults to env GITHUB_REF or main)
  -h, --help             Show this help text
USAGE
}

resolve_abs_path() {
  local path="$1"
  if command -v python3 >/dev/null 2>&1; then
    python3 - "$path" <<'PY'
import os, sys
print(os.path.abspath(sys.argv[1]))
PY
    return 0
  fi
  if [ -d "$path" ]; then
    (cd "$path" && pwd)
  else
    local dir
    dir="$(dirname "$path")"
    local base
    base="$(basename "$path")"
    (cd "$dir" >/dev/null 2>&1 && printf '%s/%s\n' "$(pwd)" "$base") || return 1
  fi
}

read_env_value() {
  local file="$1"
  local key="$2"
  if [ ! -f "$file" ]; then
    return 0
  fi
  if command -v python3 >/dev/null 2>&1; then
    python3 - "$file" "$key" <<'PY'
import sys
from pathlib import Path
path = Path(sys.argv[1])
key = sys.argv[2]
value = ""
for raw in path.read_text(encoding="utf-8").splitlines():
    line = raw.strip()
    if not line or line.startswith('#') or '=' not in line:
        continue
    k, v = line.split('=', 1)
    if k.strip() == key:
        v = v.strip()
        if len(v) >= 2 and v[0] == v[-1] and v[0] in "\"'":
            v = v[1:-1]
        value = v
        break
print(value, end="")
PY
  else
    local line
    line=$(grep -E "^${key}=" "$file" | tail -n1 || true)
    line="${line#${key}=}"
    line="${line%%$'\r'}"
    if [[ "${line}" =~ ^".*"$ ]] || [[ "${line}" =~ ^'.*'$ ]]; then
      line="${line:1:${#line}-2}"
    fi
    printf '%s' "$line"
  fi
}

# Generate random password/key
generate_random() {
  local length="${1:-16}"
  if command -v openssl >/dev/null 2>&1; then
    openssl rand -base64 "$length" | tr -d '\n'
  else
    # Fallback using /dev/urandom
    head -c "$length" /dev/urandom | base64 | tr -d '\n'
  fi
}

# Prompt for a secret with description and optional default
prompt_secret() {
  local var_name="$1"
  local description="$2"
  local default_value="$3"
  local is_required="$4"
  local value=""
  
  echo
  echo "📋 $var_name: $description"
  if [ -n "$default_value" ]; then
    if [[ "$default_value" == "AUTO_GENERATE"* ]]; then
      local gen_length="${default_value#AUTO_GENERATE:}"
      gen_length="${gen_length:-16}"
      default_value=$(generate_random "$gen_length")
      echo "   Auto-generated: $default_value"
    fi
    echo "   Default: $default_value"
  fi
  
  if [ "$is_required" = "true" ]; then
    echo "   (REQUIRED)"
  else
    echo "   (OPTIONAL - press Enter to skip)"
  fi
  
  printf "   Enter value: "
  read -r value
  
  if [ -z "$value" ]; then
    if [ -n "$default_value" ]; then
      value="$default_value"
    elif [ "$is_required" = "true" ]; then
      echo "   ❌ This field is required. Please enter a value."
      prompt_secret "$var_name" "$description" "$default_value" "$is_required"
      return
    fi
  fi
  
  # Validate based on var type
  case "$var_name" in
    DOCKER_PAT)
      if [[ ! "$value" =~ ^(ghp_|dckr_) ]] && [ -n "$value" ]; then
        echo "   ⚠️  Warning: Docker PAT should start with 'ghp_' or 'dckr_'"
      fi
      ;;
    *_PASSWORD)
      if [ ${#value} -lt 8 ] && [ -n "$value" ]; then
        echo "   ⚠️  Warning: Password should be at least 8 characters"
      fi
      ;;
    OPENAI_API_KEY)
      if [[ ! "$value" =~ ^sk- ]] && [ -n "$value" ]; then
        echo "   ⚠️  Warning: OpenAI API key should start with 'sk-'"
      fi
      ;;
  esac
  
  # Set global variable for caller to use
  PROMPT_VALUE="$value"
}

# Interactive setup for all customer secrets
prompt_for_secrets() {
  local sensitive_file="$1"
  
  echo
  echo "🔐 MimIR Setup: Customer Secrets Configuration"
  echo "================================================"
  echo "We'll walk through each required secret. You can:"
  echo "• Press Enter to use auto-generated values (for passwords)"
  echo "• Enter your own values (for API keys provided to you)"
  echo "• Press Enter to skip optional items"
  echo
  
  # Start building the env file
  cat > "$sensitive_file" <<EOF
# .env.sensitive: Customer Secrets (Auto-generated by installer)
# Do NOT commit this file. Generated on $(date)

EOF
  
  # Docker Authentication (Required)
  echo "Step 1/6: Docker Authentication"
  prompt_secret "DOCKER_PAT" "Docker Personal Access Token (provided to you)" "" "true"
  echo "DOCKER_PAT=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  
  # Database Passwords (Required - Auto-generate)
  echo "Step 2/6: Database Passwords"
  prompt_secret "CLICKHOUSE_PASSWORD" "ClickHouse database password" "AUTO_GENERATE:16" "true"
  echo "CLICKHOUSE_PASSWORD=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  prompt_secret "REDIS_PASSWORD" "Redis cache password" "AUTO_GENERATE:16" "true"
  echo "REDIS_PASSWORD=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  
  # AI/ML API Keys (Required)
  echo "Step 3/6: AI/ML Service Keys"
  prompt_secret "OPENAI_API_KEY" "OpenAI API key (starts with sk-)" "" "true"
  echo "OPENAI_API_KEY=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  prompt_secret "VOYAGE_API_KEY" "Voyage AI embeddings key" "" "true"
  echo "VOYAGE_API_KEY=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  prompt_secret "UNSTRUCTURED_API_KEY" "Unstructured.io document processing key" "" "true"
  echo "UNSTRUCTURED_API_KEY=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  
  # Application Secrets (Required - Auto-generate)
  echo "Step 4/6: Application Security Keys"
  prompt_secret "SECRET_KEY" "Main application secret key" "AUTO_GENERATE:32" "true"
  echo "SECRET_KEY=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  prompt_secret "TOKEN_SECRET_KEY" "Token signing key" "AUTO_GENERATE:24" "true"
  echo "TOKEN_SECRET_KEY=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  prompt_secret "FERNET_KEY_PATTERN" "Encryption key (Fernet)" "AUTO_GENERATE:32" "true"
  echo "FERNET_KEY_PATTERN=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  
  # Optional API Keys
  echo "Step 5/6: Optional API Keys (press Enter to skip)"
  prompt_secret "AZURE_OPENAI_API_KEY" "Azure OpenAI key (if using Azure)" "" "false"
  if [ -n "$PROMPT_VALUE" ]; then
    echo "AZURE_OPENAI_API_KEY=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  fi
  prompt_secret "AZURE_OPENAI_API_BASE" "Azure OpenAI endpoint (if using Azure)" "" "false"
  if [ -n "$PROMPT_VALUE" ]; then
    echo "AZURE_OPENAI_API_BASE=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  fi
  prompt_secret "HF_TOKEN" "HuggingFace token (for faster model downloads)" "" "false"
  if [ -n "$PROMPT_VALUE" ]; then
    echo "HF_TOKEN=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  fi
  prompt_secret "GOOGLE_MAPS_API_KEY" "Google Maps API key (if using location features)" "" "false"
  if [ -n "$PROMPT_VALUE" ]; then
    echo "GOOGLE_MAPS_API_KEY=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  fi
  
  # OIDC/SSO (Optional)
  echo "Step 6/6: Single Sign-On (Optional - press Enter to skip)"
  prompt_secret "OIDC_ISSUER_URL" "OIDC provider URL (e.g., https://your-auth0.auth0.com)" "" "false"
  if [ -n "$PROMPT_VALUE" ]; then
    echo "OIDC_ISSUER_URL=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  fi
  prompt_secret "OIDC_CLIENT_ID" "OIDC client ID" "" "false"
  if [ -n "$PROMPT_VALUE" ]; then
    echo "OIDC_CLIENT_ID=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  fi
  prompt_secret "OIDC_CLIENT_SECRET" "OIDC client secret" "" "false"
  if [ -n "$PROMPT_VALUE" ]; then
    echo "OIDC_CLIENT_SECRET=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  fi
  prompt_secret "OAUTH2_PROXY_COOKIE_SECRET" "OAuth2 cookie secret" "AUTO_GENERATE:32" "false"
  if [ -n "$PROMPT_VALUE" ]; then
    echo "OAUTH2_PROXY_COOKIE_SECRET=\"$PROMPT_VALUE\"" >> "$sensitive_file"
  fi
  
  # Add fixed values
  cat >> "$sensitive_file" <<'EOF'

# Fixed values (do not change)
DOCKER_REGISTRY="docker.io"
DOCKER_USERNAME="quicklookup"
CLICKHOUSE_USER="default"
EOF
  
  echo
  echo "✅ Secrets configuration complete! Saved to $sensitive_file"
  echo
}

# Download example env file from GitHub if missing
download_example() {
  local example_name="$1"
  local target_example="$2"
  if [ ! -f "$target_example" ]; then
    echo "Downloading $example_name from GitHub..."
    curl -s -L "https://raw.githubusercontent.com/${GITHUB_OWNER}/${GITHUB_REPO}/${DEFAULT_GITHUB_REF}/${GITHUB_PATH}/${example_name}" -o "$target_example"
    if [ $? -ne 0 ]; then
      echo "Failed to download $example_name. Check internet or GITHUB_REF." >&2
      exit 1
    fi
  fi
}

# Setup env files with interactive prompts (smoothest experience)
setup_env_files() {
  local target_dir="$1"
  local non_sensitive=".env.non-sensitive"
  local sensitive=".env.sensitive"
  
  # Download non-sensitive example and copy (ready with defaults)
  download_example ".env.example.non-sensitive" "$non_sensitive"
  if [ ! -f "$non_sensitive" ]; then
    cp "$non_sensitive" "$non_sensitive"
    echo "✅ Created $non_sensitive with safe defaults."
  fi
  
  # For sensitive: Interactive prompts instead of editor
  if [ ! -f "$sensitive" ] && [ "$NON_INTERACTIVE" != "true" ]; then
    prompt_for_secrets "$sensitive"
  elif [ ! -f "$sensitive" ]; then
    echo "Run without --no-interactive for guided setup, or create $sensitive manually." >&2
    exit 1
  else
    echo "✅ Using existing $sensitive"
  fi

  # Set ENV_FILES_ABS to these local files (absolute for compose)
  ENV_FILES_ABS=()
  ENV_FILES_ABS+=("$(resolve_abs_path "$non_sensitive")")
  ENV_FILES_ABS+=("$(resolve_abs_path "$sensitive")")
  ENV_FILES_FOR_AUTH=("${ENV_FILES_ABS[@]}")
}

TARGET_DIR="$DEFAULT_TARGET_DIR"
ENV_FILES_INPUT=""
RUN_COMPOSE=true
NON_INTERACTIVE=false
CLI_GITHUB_REF=""
ENV_FILES_ABS=()
ENV_FILES_FOR_AUTH=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    -t|--target)
      [[ $# -lt 2 ]] && { echo "Missing value for $1" >&2; exit 1; }
      TARGET_DIR="$2"
      shift 2
      ;;
    -e|--env-file)
      [[ $# -lt 2 ]] && { echo "Missing value for $1" >&2; exit 1; }
      ENV_FILES_INPUT="$2"
      shift 2
      ;;
    --no-up)
      RUN_COMPOSE=false
      shift
      ;;
    --no-interactive)
      NON_INTERACTIVE=true
      shift
      ;;
    --ref)
      [[ $# -lt 2 ]] && { echo "Missing value for $1" >&2; exit 1; }
      CLI_GITHUB_REF="$2"
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "Unknown option: $1" >&2
      usage >&2
      exit 1
      ;;
  esac
done

if [[ -n "$ENV_FILES_INPUT" ]]; then
  IFS=',' read -ra temp_files <<< "$ENV_FILES_INPUT"
  for file in "${temp_files[@]}"; do
    local abs_file
    abs_file="$(resolve_abs_path "$file")"
    if [ -n "$abs_file" ] && [ -f "$abs_file" ]; then
      ENV_FILES_ABS+=("$abs_file")
    else
      echo "Environment file not found or invalid: $file" >&2
      exit 1
    fi
  done
  ENV_FILES_FOR_AUTH=("${ENV_FILES_ABS[@]}")
else
  # Frictionless: Auto-setup env files in cwd if not provided
  setup_env_files "$TARGET_DIR"
fi

if ! command -v python3 >/dev/null 2>&1; then
  echo "python3 is required" >&2
  exit 1
fi

if ! command -v curl >/dev/null 2>&1; then
  echo "curl is required" >&2
  exit 1
fi

if ! command -v tar >/dev/null 2>&1; then
  echo "tar is required" >&2
  exit 1
fi

# Read from env files in order, last overrides
GITHUB_TOKEN_VALUE="${GITHUB_TOKEN:-}"
GITHUB_REF="${CLI_GITHUB_REF:-${GITHUB_REF:-$DEFAULT_GITHUB_REF}}"
for env_file in "${ENV_FILES_ABS[@]}"; do
  token_val=$(read_env_value "$env_file" "GITHUB_TOKEN")
  if [ -n "$token_val" ]; then
    GITHUB_TOKEN_VALUE="$token_val"
  fi
  ref_val=$(read_env_value "$env_file" "GITHUB_REF")
  if [ -n "$ref_val" ]; then
    GITHUB_REF="$ref_val"
  fi
done

TMP_DIR="$(mktemp -d)"
cleanup() {
  rm -rf "$TMP_DIR"
}
trap cleanup EXIT

DOWNLOAD_DIR="$TMP_DIR/download"
mkdir -p "$DOWNLOAD_DIR"

export OWNER="$GITHUB_OWNER"
export REPO="$GITHUB_REPO"
export GH_PATH="$GITHUB_PATH"
export DEST="$DOWNLOAD_DIR"
export GH_REF="$GITHUB_REF"
export GITHUB_TOKEN_DOWNLOAD="$GITHUB_TOKEN_VALUE"

python3 - <<'PY'
import json
import os
import sys
from pathlib import Path
from urllib import request, error

owner = os.environ['OWNER']
repo = os.environ['REPO']
path = os.environ['GH_PATH']
dest = Path(os.environ['DEST'])
ref = os.environ.get('GH_REF', '')
token = os.environ.get('GITHUB_TOKEN_DOWNLOAD', '')

base_url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path.strip('/')}"
if ref:
    root_url = f"{base_url}?ref={ref}"
else:
    root_url = base_url

def github_request(url: str, accept: str | None = None) -> bytes:
    headers = {'User-Agent': 'cxs-installer', 'Accept': accept or 'application/vnd.github.v3+json'}
    if token:
        headers['Authorization'] = f'token {token}'
    req = request.Request(url, headers=headers)
    try:
        with request.urlopen(req) as resp:
            return resp.read()
    except error.HTTPError as exc:
        message = exc.read().decode('utf-8', errors='ignore')
        raise SystemExit(f"GitHub request failed ({exc.code}): {url} - {message}") from exc

def ensure_list(data):
    if isinstance(data, list):
        return data
    return [data]

def save_file(item, target: Path) -> None:
    data = github_request(item['url'], accept='application/vnd.github.v3.raw')
    target.parent.mkdir(parents=True, exist_ok=True)
    target.write_bytes(data)

def process(url: str, target_dir: Path) -> None:
    payload = github_request(url)
    data = json.loads(payload.decode('utf-8'))
    items = ensure_list(data)
    target_dir.mkdir(parents=True, exist_ok=True)
    for entry in items:
        entry_type = entry.get('type')
        name = entry.get('name')
        if not name:
            continue
        target_path = target_dir / name
        if entry_type == 'file' or entry_type == 'symlink':
            save_file(entry, target_path)
        elif entry_type == 'dir':
            process(entry['url'], target_path)
        else:
            # Skip unsupported types (e.g., submodule)
            continue

process(root_url, dest)
PY

STACK_SOURCE="$DOWNLOAD_DIR"
mkdir -p "$TARGET_DIR"
TARGET_DIR_ABS="$(cd "$TARGET_DIR" && pwd)"
STACK_TARGET="$TARGET_DIR_ABS/.local"

echo "Preparing target directory at $STACK_TARGET"
rm -rf "$STACK_TARGET"
mkdir -p "$STACK_TARGET"

tar -C "$STACK_SOURCE" -cf - . | tar -C "$STACK_TARGET" -xf -

echo "Stack files ready in $STACK_TARGET"

if [ "$RUN_COMPOSE" = false ]; then
  echo "Skipping docker compose up."
  exit 0
fi

if ! command -v docker >/dev/null 2>&1; then
  echo "Docker CLI is required" >&2
  exit 1
fi

# Get last env file for auth/creds (bash 3.2 compatible)
if [ ${#ENV_FILES_FOR_AUTH[@]} -eq 0 ]; then
  echo "No environment files available. Run setup_env_files first." >&2
  exit 1
fi
last_env_index=$(( ${#ENV_FILES_FOR_AUTH[@]} - 1 ))
last_env="${ENV_FILES_FOR_AUTH[$last_env_index]}"

# Read Docker creds from last env file (sensitive)
DOCKER_REGISTRY=$(read_env_value "$last_env" "DOCKER_REGISTRY")
DOCKER_USERNAME=$(read_env_value "$last_env" "DOCKER_USERNAME")
DOCKER_PAT=$(read_env_value "$last_env" "DOCKER_PAT")
DOCKER_REGISTRY=${DOCKER_REGISTRY:-docker.io}

if [ -z "$DOCKER_USERNAME" ] || [ -z "$DOCKER_PAT" ]; then
  echo "DOCKER_USERNAME and DOCKER_PAT must be set in the last env file ($last_env)" >&2
  echo "Current file contents:" >&2
  head -5 "$last_env" >&2 || echo "File not readable" >&2
  exit 1
fi

# Validate key sensitive vars in last file before up (best practice - up to date with all critical)
CLICKHOUSE_PASSWORD=$(read_env_value "$last_env" "CLICKHOUSE_PASSWORD")
REDIS_PASSWORD=$(read_env_value "$last_env" "REDIS_PASSWORD")
OPENAI_API_KEY=$(read_env_value "$last_env" "OPENAI_API_KEY")
VOYAGE_API_KEY=$(read_env_value "$last_env" "VOYAGE_API_KEY")
UNSTRUCTURED_API_KEY=$(read_env_value "$last_env" "UNSTRUCTURED_API_KEY")
SECRET_KEY=$(read_env_value "$last_env" "SECRET_KEY")

if [ -z "$CLICKHOUSE_PASSWORD" ] || [ -z "$REDIS_PASSWORD" ] || [ -z "$OPENAI_API_KEY" ] || [ -z "$VOYAGE_API_KEY" ] || [ -z "$UNSTRUCTURED_API_KEY" ] || [ -z "$SECRET_KEY" ]; then
  echo "Required secrets missing in last env file ($last_env): CLICKHOUSE_PASSWORD, REDIS_PASSWORD, OPENAI_API_KEY, VOYAGE_API_KEY, UNSTRUCTURED_API_KEY, SECRET_KEY." >&2
  echo "Fill .env.sensitive and rerun." >&2
  exit 1
fi

echo "Logging into Docker registry $DOCKER_REGISTRY..."
if ! printf '%s' "$DOCKER_PAT" | docker login "$DOCKER_REGISTRY" -u "$DOCKER_USERNAME" --password-stdin >/dev/null; then
  echo "Docker login failed" >&2
  exit 1
fi

COMPOSE_BIN=(docker compose)
if ! docker compose version >/dev/null 2>&1; then
  if command -v docker-compose >/dev/null 2>&1; then
    COMPOSE_BIN=(docker-compose)
  else
    echo "Docker Compose is not available" >&2
    exit 1
  fi
fi

COMPOSE_ARGS=()
for env_file in "${ENV_FILES_ABS[@]}"; do
  COMPOSE_ARGS+=("--env-file" "$env_file")  # Absolute paths ensure compose finds them
done
COMPOSE_ARGS+=("-f" "docker-compose.mimir.onprem.yml" "up" "-d")

pushd "$STACK_TARGET" >/dev/null

echo "Running docker compose up..."
"${COMPOSE_BIN[@]}" "${COMPOSE_ARGS[@]}"

popd >/dev/null

echo "🎉 Installation complete! Access your MimIR setup at http://localhost"
echo "Verify with 'docker compose ps' from $STACK_TARGET."